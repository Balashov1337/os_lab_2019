# Лабораторная работа №6

## Задание 1

### Необходимые знания

1. TCP и TCP/IP
  TCP/IP - это набор протоколов, который задает стандарты связи между компьютерами и содержит подробные соглашения о маршрутизации и межсетевом взаимодействии. TCP/IP обеспечивает связь подключенных к сети компьютеров, обычно называемых хостами. Любую сеть можно подключить к другой сети и организовать связь с ее хостами. TCP/IP обладает важным преимуществом: он обеспечивает аппаратную независимость.

2. TCP vs UDP
  Важный часть комплекта TCP/IP - User Datagram Protocol (UDP, протокол пользовательских дейтаграмм), который похож на TCP, но более примитивен. TCP - "надежный" протокол, потому что он обеспечивает проверку на наличие ошибок и обмен подтверждающими сообщениями, чтобы данные достигали своего места назначения заведомо без искажений. UDP - "ненадежный" протокол, ибо не гарантирует, что дейтаграммы будут приходить в том порядке, в котором были посланы, и даже того, что они придут вообще.
1. Системный вызов `socket`
    ```
    #include <sys/socket.h>
    int socket(int domain, int type, int protocol);
    ```
    В полях domain, type и protocol передается соответственно семейство, тип и протокол для создаваемого сокета.
  >  Первый параметр указывает, к какому семейству протоколов относится создаваемый сокет, а второй и     третий параметры определяют конкретный протокол внутри данного семейства.Параметр domain задает домен соединения: выбирает набор протоколов, которые будут использоваться для создания соединения.(AF_INET	IPv4 протоколы Интернет)

  >  Второй параметр служит для задания вида интерфейса работы с сокетом – будет это потоковый сокет, сокет для работы с датаграммами или какой-либо иной.Сокет имеет тип type, задающий семантику коммуникации.SOCK_STREAM Обеспечивает создание двусторонних надежных и последовательных потоков байтов , поддерживающих соединения. Может также поддерживаться механизм внепоточных данных.

  >Третий параметр указывает протокол для заданного типа интерфейса.Параметр protocol задает конкретный протокол, который работает с сокетом. Обычно существует только один протокол, задающий конкретный тип сокета в определенном семействе протоколов, в этом случае protocol может быть определено, как 0

    Возвращает файловый дескриптор(>=0), который будет использоваться как ссылка на созданный коммуникационный узел

    В стеке протоколов TCP/IP существует только один протокол для потоковых сокетов – TCP и только один протокол для датаграммных сокетов – UDP, поэтому для транспортных протоколов TCP/IP третий параметр игнорируется.

    Для создания сокета в операционной системе служит системный вызов socket() . Для транспортных протоколов семейства TCP/IP существует два вида сокетов: UDP-сокет – сокет для работы с датаграммами, и TCP сокет – потоковый сокет.

2. Системный вызов `bind`
bind привязывает имя к сокету
 `int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) `
Когда сокет создается с помощью socket (2), он существует в пространстве имен (семейство адресов), но ему не назначен адрес. bind () назначает адрес, указанный в addr, сокету, указанному в файле

2. Системный вызов `listen`
`int listen(int sockfd, int backlog);`
Функция listen () помечает сокет, на который ссылается sockfd, как пассивный сокет, то есть сокет, который будет использоваться для приема входящих запросов на соединение с помощью accept (2).
>Аргумент sockfd является дескриптором файла, который ссылается на сокет типа SOCK_STREAM или SOCK_SEQPACKET.
>Аргумент backlog определяет максимальную длину, до которой может увеличиваться очередь ожидающих соединений для sockfd.

3. Системный вызов `accept`
Системный вызов accept () используется с типами сокетов на основе соединений
accept(SOCK_STREAM, SOCK_SEQPACKET).
Он извлекает первый запрос на соединение в очереди ожидающих соединений для прослушивающего сокета.

4. Системный вызов `recv`
Вызовы recv используются для получения сообщений из сокета. Они могут использоваться для получения данных как на сокетах без подключения, так и на сокетах, ориентированных на соединение

5. Системный вызов `send`
Вызов send () может использоваться только тогда, когда сокет находится в подключенном состоянии (так что предполагаемый получатель известен).

6. Системный вызов `close`
close () закрывает файловый дескриптор, так что он больше не ссылается на какой-либо файл и может быть использован повторно.
7. Системный вызов `connect`
Системный вызов connect () соединяет сокет, указанный дескриптором файла sockfd, с адресом, указанным в addr.

В предыдущей лабораторной работе вы распаралелливали вычисление факториала по модулю с помощью потоков. В этой работе вы пойдете еще дальше: вы распараллелите эту работу еще и между серверами.

Необходимо закончить `client.c` и `server.c`:

Клиент в качетсве аргументов командной сроки получает `k`, `mod`, `servers`, где `k` это факториал, который необходимо вычислить (`k! % mod`), `servers` это путь до файла, который содержит сервера (`ip:port`), между которыми клиент будет распараллеливать соединения.

Сервер получает от клиента "кусок" своих вычислений и `mod`, в ответ отсылает клиенту результат этих вычислений.

### Ресурсы

1. [Manual pages](http://man7.org/linux/man-pages/)
2. [TCP [Wikipedia]](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)

### Заметка

Обратите внимание, что клиент сейчас дожидается завершения работы с каждым сервером в цикле, т.е. последовательно. Это значит, что вам нужно подумать, как распараллелить работу с каждым сервером, чтобы сервера могли работать параллельно. Есть несколько вариантов, как это можно сделать, опираясь на уже пройденный вами материал, никто вас не ограничивает в выборе способа, но выбранный вариант вам необходимо объяснить.

## Задание 2

Создать makefile для программ клиента и сервера

## Задание 3

Найти дублирующийся код в двух приложениях и вынести его в библиотеку. Добавить изменения в makefile.

## Задание 4 (опционально)

Получить доступ из внешнего мира. Преподаватель может попросить вас объединиться с другим студентом, чтобы проденмонстрировать, как будет работать ваш сервер с чужим клиентом. Для этого в Codenvy зайдите в Servers (Dashboard->Workspace->Servers), добавьте порт, на котором будет висеть ваш сервер, презагрузите workspace на этой же вкладке браузера. Рядом с созданным "сервером" вы должны увидеть "белый" адрес, по которому вы можете обратиться к вашему серверу.

## Перед тем, как сдавать

Залейте ваш код в ваш репозиторий на GitHub. Убедитесь, что вы не добавляете в репозиторий бинарные файлы (программы, утилиты, библиотеки и т.д.).
